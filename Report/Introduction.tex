% !TeX root = Report.tex
\section{Introduction}

\subsection{What is a Wireless Sensor Network?}

A wireless sensor network (WSN) is a collection of motes that are capable of wireless communication and ability to sense their surrounding environment \cite{Mica2002,TankBible}. To communicate wirelessly each node is equipped with a radio that allows them to communicate with their neighbouring nodes within a given range. They typically contain a simple CPU that is capable of controlling the hardware such as the radio and sensors, processing events (such as messages being sent and received) and all the other computation necessary for operation. As the hardware is wireless in all meanings of the word, the motes are not plugged into the mains power supply - this means the motes must run off stored energy in a battery. The fact that they run off a battery is very important as it means there is only a finite supply of energy. As the energy available will eventually run out the platform being deployed (the hardware and the software) must be developed around this limitation to maximise the system's lifetime to maximise the utility that can be got out of the system \cite{1331424}.

While a limited energy source is the predominant characteristic of a wireless sensor node, there are numerous other traits or issues that can be considered. For instance it is possible for these nodes to be mobile (for example an ad-hoc network of PDAs) \cite{4224091} which leads to very interesting behaviour in handling communication between these nodes. Nodes are usually equipped with the same features (such as the same wireless radio), need to withstand harsh outdoor conditions (as that is where they are typically deployed) \cite{SzewczykPMC04, Werner-Allen:2006:FYV:1298455.1298491} and are used in an unattended fashion \cite{1437066}.

As energy usage is limited wireless sensor nodes tend not to use expensive broadcasting protocols such as IEEE 802.11 \cite{Mica2002}, but instead use much simpler alternatives to save energy. For example wireless protocols such as IEEE 802.15.4 ZigBee \cite{1253873, 4014617} are designed to be used by wireless sensor networks and have a lower energy usage associated with them. Some applications rely on even lower level behaviour specified by a certain MAC layer \cite{5751321,4469515,?,BMAC,SMAC,XMAC}, these applications involve a trade-off between development time and energy usage. Where simplicity is often sacrificed for decreased energy usage. Using these simple protocols unfortunately has the downside of meaning that broadcasts are subject to several types of collisions and message losses. So it is very important that the software running on the nodes is designed to handle these cases.

As wireless sensor nodes operate in harsh outdoors condition, there is a high probability of them failing. These faults can range from hardware damage caused by environmental conditions or tampering, software bugs, or simply a denial of service caused by nodes running out of power. So algorithms and software need to be designed to handle these potential failures, otherwise they risk catastrophic failure when they encounter these issues.

\subsection{Debugging Distributed Systems}

Like any system, software or otherwise, developed by humans there is the potential for humans to make mistakes. Mistakes can be benign or they can cause incorrect behaviour and failures. Developing tools to detect these issues and notify the developer so they can be corrected is an incredibly important part of any toolchain. For example the GNU toolchain has utilities such as gdb \cite{?} which allows breakpoint in code to be set and program state to be examined at that point. There are also numerous other tools that look for memory issues (valgrind \cite{?}), security flaws \cite{?} and other classes of bugs. Debugging isolated systems is considered to be a difficult task \cite{?}, debugging distributed systems is considered even harder \cite{345131}.

Developing a distributed system is considered harder because (i) multiple processes execute in parallel, this means that (ii) variables may be updated independently or in repose to other processes and (iii) programming languages are not well suited to develop distributed programs \cite{93692,345131}. As developing distributed systems is hard it also means that testing and debugging are also hard.

When considering a distributed system if you want to examine the state of a system at a given point you cannot simply set a breakpoint in your local binary. The solution to this debugging is non-trivial due to the difficulties that arise because distributed systems are non-deterministic with respect to message communications \cite{?}. Be it when the message started transmission, how long it took, if it succeeded or in what order transmissions occurred. So every time a distributed program is run it is possible for a different result to be obtained, due to the different order of execution. This goes against one of the usual assumptions of debugging traditional applications where it is assume that one execution with a set of inputs will execute in exactly the same way again with the same set of inputs \cite{?} (i.e. determinism).

As the execution may be different each time it is not suitable to wait for a bug to effect the system and then try to work out what the bug is and how to fix it. But the system needs to be paying attention to itself and be able to report if there is an issue. One way to do this it to test if the system satisfies some global predicate, of which there has been much work to find an check different classes of these predicates \cite{553309,345831,277788}. However, of all the work that has been done little of it has focused on wireless sensor networks, where an important focus is perhaps a trade-off of the accuracy or the reportability of a predicate with the aim of reducing energy usage. We intend to focus on developing a system that can accurately evaluate predicates and provide useful information about real sensor networks running outside of a simulator.


\subsection{Related Work}

\subsubsection*{Classes of Distributed Predicates}

To begin with it is important to understand what predicates are relevant to distributed systems. First off we have a distinction between global and local predicates, global predicates involve ``taking a consistent global snapshot of the system and checking whether the snapshot satisfies the global predicate'' \cite{277788} and local predicates instead work with a subset of the network \cite{553309}. These predicates have also have a notion of stability, a stable predicate will remain true once it has turned true (e.g. termination), whereas unstable predicates can alternate between true and false. Finally there is a distinction between weak and strong, where a weak predicate holds ``if there exists an observation where the predicate is true'' and a strong predicate holds if ``it is true for all observers of the distributed computation''.  \cite{553309,Cooper:1991:CDG:127695.122774}

\begin{comment}
\cite{1382572, 749477, ?}. However, in distributed systems there are additional challenges to overcome \cite{5010224}

What can be meant by `detecting bugs', in non-distributed systems there are many different classes of bugs \cite{?}, when we consider distributed systems many of those bugs have new vectors in which they can arise. For example deadlock can now occur across motes if both motes are waiting on receiving a message the other mote should be sending. The fact that these systems are distributed means that debugging these kind of problems becomes harder \cite{?}. Also there are new ways bugs can arise, for example in the routing of information, if a message being sent is stuck being transmitted in a cycle of nodes it will never reach its destination. This type of problem requires lots of resources (either memory or large messages) to be able to effectively debug \cite{?}.
\end{comment}


\subsubsection*{Existing Sensor Network Predicate Checking Tools}


\subsubsection*{Practical Sensor Network Deployments}



