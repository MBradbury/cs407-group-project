% !TeX root = Report.tex
\section{Practical Experience}

\subsection{Sensor Data Conversion}
Sensors didn't provide data in human understandable formats. Instead they were provided in a raw format that were dependant on several hardware properties of the sensors (such as voltage levels and the number of bits of data a sensor can report). So we  had to convert from raw sensor data to expected results using equations found in \cite{sensiriondatasheet}.

\subsection{Uploading to the motes}
Command used
\begin{listing}
\begin{minted}[fontsize=\small]{bash}
sudo make example-unicast.upload DEFINES=HELLOWORLD,NODE_ID=1 MOTES=/dev/ttyUSB0
\end{minted}
\end{listing}
Adding .upload to the end of the project name, will start the upload to the motes. The MOTES variable is used to locate the USB port for the mote.

The NODE\_ID is used to set the rime address on the nodes. Provided the following macro is inserted into the code. This is important to do because otherwise the MAC address of the node will not be set. Even if the rime address of the node is set, the lack of a MAC address will cause message sent with unicast primitives to fail to arrive, as the address is not correctly set.

\begin{listing} 
\begin{minted}[fontsize=\small]{c}
#ifdef NODE_ID
node_id_burn(NODE_ID);
#endif
\end{minted}
\end{listing}


\subsection{Power Levels}
Using the low power levels (3 or lower) resulted in very unreliable transmission rates/distances. We believe that this was caused by the environment that we were testing in (DCS building), which we expect the traffic on the 2.4GHz frequency to be very busy due to the number of phones and wireless devices in the department.

\subsection{Transmission Ranges}
When developing our mote applications in the simulator there is a very useful feature that allows one to see what the transmission radius of a selected node is. This help developers to work out what the expected behaviour of a piece of software should be. When developing in real-world scenarios, we found that we were never quite sure if our software was simply not working in a real-world environment or if the motes were placed too close to each other or too far.

\subsection{Communication Between Mote and Computer}
To be able to send and receive information between an application running on a mote and an application running on the computer the mote is connected to we needed to use several applications to assist in the data transfer. The easiest flow of data was from the mote to the computer as Contiki supports writing to \verb|stdout| which can then be read using a tool called \verb|serialdump|. Unfortunately Contiki doesn't support writing to \verb|stdout| so we had to develop and alternative method to read data sent from a computer. Also when sending data from the computer application to the mote application we couldn't simply open a filestream in Java and write to that (and expected Contiki to receive it), so we also had to come up with a custom way to do this.
