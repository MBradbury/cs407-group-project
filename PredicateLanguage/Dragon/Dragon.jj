options {
  LOOKAHEAD = 1;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  STATIC = true;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = false;
  IGNORE_CASE = false;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
  FORCE_LA_CHECK = false;
}

PARSER_BEGIN(Dragon)

import java.io.*;
import java.util.*;
import com.google.common.io.LittleEndianDataOutputStream;

public class Dragon
{
	public static void main(String args[]) throws ParseException, Exception
	{
		Dragon parser = new Dragon(System.in);
		ArrayList<Opcode> opcodes = parser.Input();
		
		transformJumps(opcodes);
		
		for (Opcode op : opcodes)
		{
			System.err.print(op.getName());
			
			ArrayList<Arg> opArgs = op.getArgs();
			
			for (Arg arg : opArgs)
			{
				System.err.print(" ");
				System.err.print(arg.toString());
			}
			
			if (op.getLabel() != null)
			{
				System.err.print(" (Label=");
				System.err.print(op.getLabel());
				System.err.print(")");
			}
			
			System.err.println();
		}
		
		ByteArrayOutputStream os = new ByteArrayOutputStream();
		
		// Big-endian
		//DataOutputStream out = new DataOutputStream(os);
		
		// Little-endian
		LittleEndianDataOutputStream out = new LittleEndianDataOutputStream(os);
		
		try
		{
			for (Opcode op : opcodes)
			{
				out.writeByte(op.getName().getValue());
				
				for (Arg arg : op.getArgs())
				{
					arg.write(out);
				}
			}
			out.flush();
		}
		catch (IOException e)
		{
			System.err.println(e);
		}
		finally
		{
			try {
				out.close();
			} catch (Exception e) {
				System.err.println(e);
			}
		}
		
		os.writeTo(System.out);
	}
	
	private static void transformJumps(ArrayList<Opcode> opcodes) throws Exception
	{
		for (Opcode op : opcodes)
		{
			OpcodeEnum name = op.getName();
			
			if (name == OpcodeEnum.JMP || name == OpcodeEnum.JZ || name == OpcodeEnum.JNZ)
			{
				int index = getLabelIndex(opcodes, op.getArgs().get(0).toString());
				
				System.err.println("Converting label " + op.getArgs().get(0).toString() + " to " + index);
				
				// Update the label name, with the jump position
				op.getArgs().set(0, new ByteArg(index));
			}
		}
	}
	
	private static int getLabelIndex(ArrayList<Opcode> opcodes, String label) throws Exception
	{
		for (int i = 0; i != opcodes.size(); ++i)
		{
			Opcode op = opcodes.get(i);
			if (op.getLabel() != null && op.getLabel().equals(label))
			{
				return i;
			}
		}
		
		throw new Exception("Failed to find label called `" + label + "'");
	}
}

enum OpcodeEnum
{
	HALT(0),

	IPUSH(1), IPOP(2), FPUSH(3), FPOP(4),
	IFETCH(5), ISTORE(6), FFETCH(7), FSTORE(8),
  
	AFETCH(9), ALEN(10),

	ASUM(11), AMEAN(12), AMAX(13), AMIN(14),

	CALL(15),

	ICASTF(16), FCASTI(17),

	JMP(18), JZ(19), JNZ(20),

	IADD(21), ISUB(22), IMUL(23), IDIV1(24), IDIV2(25), IINC(26),
	IEQ(27), INEQ(28), ILT(29), ILEQ(30), IGT(31), IGEQ(32),

	FADD(33), FSUB(34), FMUL(35), FDIV1(36), FDIV2(37),
	FEQ(38), FNEQ(39), FLT(40), FLEQ(41), FGT(42), FGEQ(43),

	AND(44), OR(45), XOR(46), NOT(47),
	
	IVAR(48), FVAR(49),

	IABS(50), FABS(51),

	FPOW(52);
	
	private final int value;
	
	private OpcodeEnum(int value)
	{
		this.value = value;
	}

	public int getValue()
	{
		return value;
	}
}

final class Opcode
{
	private OpcodeEnum name;
	private ArrayList<Arg> args = new ArrayList<Arg>();
	private String label;
	
	public OpcodeEnum getName() { return name; }
	public void setName(String name) { this.name = OpcodeEnum.valueOf(name); }
	
	public void addArg(Arg arg) { args.add(arg); }
	public ArrayList<Arg> getArgs() { return args; }
	
	public String getLabel() { return label; }
	public void setLabel(String label) { this.label = label; }
}

interface Arg
{
	void write(DataOutput out) throws IOException;
}

final class StringArg implements Arg
{
	private final String value;
	
	public StringArg(Token t)
	{
		value = t.image;
	}
	
	public String toString() { return value; }
	
	public void write(DataOutput out) throws IOException
	{
		throw new IOException("Should never call StringArg.write");
	}
}

final class ByteArg implements Arg
{
	private final int value;

	public ByteArg(int i) throws ArithmeticException
	{
		value = i;

		if (!(value >= 0 && value <= 255))
		{
			throw new ArithmeticException(i + " is not in the range of [0, 255]");
		}
	}
	
	public ByteArg(Token t) throws ArithmeticException
	{
		value = Integer.parseInt(t.image);

		if (!(value >= 0 && value <= 255))
		{
			throw new ArithmeticException(t.image + " is not in the range of [0, 255]");
		}
	}
	
	public String toString() { return Integer.toString(value); }
	
	public void write(DataOutput out) throws IOException
	{
		out.writeByte(value);
	}
}

final class FloatArg implements Arg
{
	private final float value;
	
	public FloatArg(Token t)
	{
		value = Float.parseFloat(t.image);
	}
	
	public String toString() { return Float.toString(value); }
	
	public void write(DataOutput out) throws IOException
	{
		out.writeFloat(value);
	}
}

final class IntArg implements Arg
{
	private final int value;
	
	public IntArg(Token t)
	{
		value = Integer.parseInt(t.image);
	}
	public IntArg(int i)
	{
		value = i;
	}
	
	public String toString() { return Integer.toString(value); }
	
	public void write(DataOutput out) throws IOException
	{
		out.writeShort(value);
	}
}

PARSER_END(Dragon)

// Whitespace

SKIP : { " " | "\t" }

// Comments

SPECIAL_TOKEN : {
	< SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")? >
}

// Opcodes

TOKEN : {
	//Keywords
	
	  <#POP :		"IPOP" | "FPOP">
	
	| <#FETCH :		"IFETCH" | "FFETCH" | "AFETCH" >
	
	| <#STORE :		"ISTORE" | "FSTORE" >
	
	| <#ABIGOP :	"ASUM" | "AMEAN" | "AMAX" | "AMIN" >
	
	| <#CAST :		"ICASTF" | "FCASTI" >
	
	| <#JUMP :		"JMP" | "JZ" | "JNZ" >
	
	| <#MATHOP :	"IADD" | "FADD" | "ISUB" | "FSUB" | "IMUL" | "FMUL" | "IDIV1" | "IDIV2" | "FDIV1" | "FDIV2" | "IINC" >
	
	| <#MATHLOP :	"IEQ" | "FEQ" | "INEQ" | "FNEQ" | "ILT" | "FLT" | "ILEQ" | "ILEQ" | "FGT" | "FGT" | "IGEQ" | "FGEQ" >
	
	| <#LOGICOP :	"AND" | "OR" | "XOR" | "NOT" >
	
	| <#VAR :		"IVAR" | "FVAR" >

	| <#ABS :		"IABS" | "FABS" >

	| < ZEROARG :	"HALT" | <POP> | <CAST> | <MATHOP> | <MATHLOP> | <LOGICOP> | <ABS> | "FPOW" >
	| < ONEARGI :	"IPUSH" >
	| < ONEARGF :	"FPUSH" >
	| < ONEARGB :	<FETCH> | <STORE> | "ALEN" | "CALL" | <VAR> >
	| < ONEARGS :	<JUMP> >
	| < TWOARGB :	<ABIGOP> >
}

// Numbers

TOKEN : {
	  < INT :		"0" | (["1"-"9"] (["0"-"9"])*) >
	| < FLOAT :		(["0"-"9"])+ "." (["0"-"9"])* >
}


// Identifiers

TOKEN : {
	  < NAME :			<LETTER> (<PARTLETTER>)* >
	| <#PARTLETTER : 	["A"-"Z", "a"-"z", "0"-"9"] >
	| <#LETTER :		["A"-"Z", "a"-"z"] >
}


TOKEN : {
	  < NEWLINE : 	"\n" | "\r" | "\r\n" >
}

ArrayList<Opcode> Input() :
{
	ArrayList<Opcode> opcodes = new ArrayList<Opcode>();
	Opcode op;
	Token label = null;
}
{
	(
		// Can optionally provide a label for this instruction
		((label = <NAME>) ":" )?

		op = Operation()
		{
			if (label != null)
			{
				op.setLabel(label.image);
				label = null;
			}
		
			opcodes.add(op);
		}

		// Can have any number of newlines between opcodes
		(<NEWLINE>)+
	)*
	<EOF>
	{
		return opcodes;
	}
}

Opcode Operation() throws ArithmeticException :
{
	Token t, t1, t2;
	Opcode op = new Opcode();
}
{
	(
		(t = <ZEROARG>)
		{ op.setName(t.image); }
		
		| (t = <ONEARGI>) (t1 = <INT>)
		{ op.setName(t.image); op.addArg(new IntArg(t1)); }

		| (t = <ONEARGF>) (t1 = <FLOAT>)
		{ op.setName(t.image); op.addArg(new FloatArg(t1)); }
		
		| (t = <ONEARGB>) (t1 = <INT>)
		{ op.setName(t.image); op.addArg(new ByteArg(t1)); }
		
		| (t = <ONEARGS>) (t1 = <NAME>)
		{ op.setName(t.image); op.addArg(new StringArg(t1)); }

		| (t = <TWOARGB>) (t1 = <INT>) (t2 = <INT>)
		{ op.setName(t.image); op.addArg(new ByteArg(t1)); op.addArg(new ByteArg(t2)); }
	)
	{
		return op;
	}
}

