\documentclass[a4paper]{article}

\usepackage[top=2cm, bottom=2cm, left=3cm, right=3cm]{geometry}

\usepackage{float}

\usepackage{multirow}

\usepackage[hyphens]{url}
\usepackage{hyperref}

\usepackage{appendix}
\usepackage[numbers]{natbib}

\usepackage{graphicx}

\newcommand{\mytilde}{\raise.17ex\hbox{$\scriptstyle\mathtt{\sim}$} }

\title{CS407 - Project Specification:\\
Towards Debugging Wireless Sensor Network Applications}
\date{25th October 2012}
\author{
	Matthew Bradbury (0921660) \and
	Tim Law () \and
	Ivan Leong () \and
	Daniel Robertson (0910210) \and
	Amit Shah (0904778) \and
	Joe Yarnall (0905247)
}

\begin{document}

\maketitle

%No numbering on first page
\pagestyle{empty}
\thispagestyle{empty}

\newpage

\pagestyle{plain}
\setcounter{page}{1}

\tableofcontents
\clearpage


\section{Introduction}

The emergence of Wireless Sensor Networks (WSNs) and the decrease in their cost and size has made it feasible to use them to solve certain types of problems. To solve these problems software will need to be developed for the WSN hardware, and like all software this software will contain bugs. As sensor networks are a distributed system, this increases the classes of bugs that software can suffer from \cite{?}, such as dead-lock, live-lock and other concurrency issues. To aid in developing reliable software for WSNs, there is thus need for tools that can assist in detecting and reporting these faults, so a developer can correct them.

\section{Motivation}

The need for debugging has been around for as long as there has been hardware that performs a task. With a famous folklore example being the case where the term debugging was coined, where a moth was picked out of a crucial relay \cite{shapiro1987etymology}. However, nowadays debugging searches for much more complicated problems than moths in machines.

When you have a sequential program it is easy to insert breakpoint or debug messages that allow you to inspect the state of the program at that given point of the execution. With distributed systems, you have the same issues that sequential programs have, but you also have to deal with the interaction of each of the different parts of the system. These interactions can be non-deterministic \cite{liu2007wids} and make inspection of the system's state at any given point much harder \cite{?}. These interactions can lead to many types of bugs that a sequential program would not encounter, such as deadlock \cite{singhal1989deadlock}, inconsistent states \cite{?} and the need to handle failures in other disconnected parts of the system \cite{?}. While there exist algorithms to solve some of these problems (for instance TCP provides stronger guarantees of message deliver than alternative protocols such as UDP \cite{?}), there are some errors that the software developer will need to ensure they do not make when writing the software. As detecting these issues is difficult and so is reporting them, tools need to be made available to the developers, so they can focus on developing their application rather than developing debugging tools to try to fix their application.

Wireless Sensor Networks are a class of distributed system, with a special property that they are energy constrained \cite{6023235}.  As they are a distributed system, the same distributed bugs can occur in software developed for them, so there is a need for tools to assist with this kind of debugging. However, as they are energy constrained developers will attempt to make certain optimisations that may not have been required with other types of distributed systems. This means any tool that is specific to them will need to be able to detect these kinds of bugs and relay them to the developer accurately.

\section{Related Work}

\textbf{TODO}

\clearpage

\section{Project Description}

\subsection{Desired Outcomes}
\begin{itemize}
	\item An application that can check to see if for a certain subsection of the network a given predicate holds
	\item A tool that can visualise logged network traffic
	\item \textbf{TODO}
\end{itemize}

\subsection{Predicate Checker}
\textbf{TODO}

\subsection{Visualisation Tool}
\textbf{TODO}

\section{Project Management}

\subsection{Management}

As this is a group project there are additional challenges to face compared to a solo project. Therefore, we plan to use the knowledge and experience gained in IB382 Project Management \cite{?} as well as our own experience to avoid common problems that could prevent us working effectively. We also plan to refer to the Project Management textbook for additional resources \cite{PMTextBook}.

As part of the management we will make sure we meet up at least once a week to discuss our current progress, and allocate tasks for the next week. We also intent to stay in contact and discuss our progress and any resources we find in between these meetings.

To ensure that the group works together towards our goals we have assigned each member a role in the project, these are listed later[TODO]. We have also elected a group leader to our project who will act as our liaison with our supervisor Arshad and who will organise our teams efforts on a weekly basis. 



\subsection{Required Resources}
\begin{itemize}
	\item Wireless Sensor Nodes and related interface hardware
	\item Operating System and Simulator for the Wireless Sensor Nodes
	\item Laptop computers to act as mobile base stations, and for development
	\item Access to academic papers that detail the previous work 
\end{itemize}

\subsection{Required Tools}
\textbf{WORK IN PROGRESS}\\

A simulator and operating system needs to be chosen that will allow us to test our code locally, then provide functionality to deploy that code to the network easily. We will now provide a comparison between the two primary operating systems, Contiki\cite{23839452} and TinyOS\cite{levis2003tossim}, and their respective simulators with a view to deciding which system best suits this projects goals and motivations.\\

TinyOS and it's simulator TOSSIM were originally created at UC Berkeley as part of the DARPA NEST Program. TinyOS is a static system where designers must allocate resources during design-time. TinyOS is also a monolithic system, in this system programs are compiled with the OS code and distributed to network nodes together as one image.\\

Contiiki was developed by Adam Dunkels and is an open source operating system designed for the Internet of Things. Contiki is a dynamic system that allows resources to be allocated and deallocated at run-time. Contiki is a modular system where programs are compiled into an individual module that can be distributed to the network nodes which run the code dynamically.\\

Both systems are event driven, however Contiki also offers native multi-threading support through proto-threads where as TinyOS does not and requires a library to gain access to threading through TinyThreads\cite{?}. TinyOS programs are implemented in nesC a variation of C designed for the TinyOS platform. The simulator COOJA can run both C and Java code but the Contiki OS can only run C code. Both systems use custom wireless networking stacks that are optimised for low power consumption. In a comparison of energy and time efficiency between Contiki and TinyOS\cite{?} it is shown that the differences between the two operating systems is negligible. The study found that Contiki is quicker at sensing, TinyOS is faster at communication between nodes and they are both equally efficient at processing tasks such as executing security algorithms.\\

We have chosen to use Contiki and COOJA for this project because it provides the most flexible system for developing applications that can quickly and easily be distributed to the network. Contiki also offers an easy to use fully functioning development environment and simulator tool all in one package. Finally, Contiki is almost as efficient as TinyOS in nearly every respect but provides all the additional features of a modular dynamic operating system and for these reasons this is why we have chosen it as the system we will develop for.  




\subsection{Schedule}

\subsubsection{Term 1}

\begin{table}[H]
	\centering
	\begin{tabular}{| l | c |}
	\hline
	\textbf{Task} & \textbf{Weeks}\\
	\hline
	Initial Research & 1-3\\
	\hline
	Specification Writing & 3\\
	\hline
	Algorithm Implementation & 4-6\\
	\hline
	Testing & 7\\
	\hline
	Deploying to Physical Hardware & 8-9\\
	\hline
	Poster Creation and Presentation Preparation & 10\\
	\hline
	\end{tabular}
\end{table}

\subsubsection{Term 2}

\begin{table}[H]
	\centering
	\begin{tabular}{| l | c |}
	\hline
	\textbf{Task} & \textbf{Weeks}\\
	\hline
	Further Research & 1\\
	\hline
	Algorithm Implementation & 2-4\\
	\hline
	Testing & 5-6\\
	\hline
	Deploying to Physical Hardware & 7-8\\
	\hline
	Report Writing & 9-10\\
	\hline
	\end{tabular}
\end{table}



\section{Potential Challenges}

Throughout our project we expect to encounter difficulties and challenges. The following are the challenges that we think may be encountered during the project and ways that these challenges could be mitigated.


\subsection{Challenges}
\begin{itemize}
	\item Needing to talk to our project supervisor (Arshad), even though he is on sabbatical.
	\item Project drifting in the wrong direction due to uncertainty.
	\item Lack of features in the simulator and/or wireless sensor network environment.
	\item Problems that we have not predicted here.
	\item Team members being unavailable to do work (eg. due to illness)
\end{itemize}

\subsection{Challenge Mitigation}
\begin{itemize}
	\item Even though Arshad is on sabbatical he should be in the department 3 days a week. Also there are other departmental staff that can assist us if Arshad is not available.
	\item If our project is not heading in the right direction, we will seek guidance from our supervisor who should be able to guide us onto the right track.
	\item If our development environment lacks features we can attempt to work around those features, or implement them (if they are very desirable) and contribute back to the open source community.
	\item For any other problem, we will use all the support that the department provides. We will make sure that the issue is discussed within the group and we will try to resolve it ourselves. if we find we cannot, then we will seek additional help.
	\item Each member will make sure that what they are doing is well documented, so that other members can easily pick up the work. Each member of the team will also ensure their work is regularly checked in to the git repository.
\end{itemize}


\section{Conclusion}

For our project we aim to create tools that aid in the debugging of Wireless Sensor Network applications. We plan to implement various predicate detection algorithms and have the network report to a base station in the case that these predicates are violated. We also plan to create a new tool that can control submitting new predicates and visualise the network state, including any predicate failures.

\clearpage

\appendixpage
\addappheadtotoc
\appendix


\section{References}
\renewcommand{\refname}{\vspace{-1cm}}
\bibliographystyle{myplainnat}
\bibliography{../References/references}

\end{document}
