options {
  LOOKAHEAD = 1;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  STATIC = true;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = false;
  IGNORE_CASE = false;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
  FORCE_LA_CHECK = false;
}

PARSER_BEGIN(Hoppy)

import java.io.PrintStream;
import java.util.*;

public class Hoppy
{
	public static void main(String args[]) throws ParseException
	{
		Hoppy parser = new Hoppy(System.in);
		parser.Input(System.out);
	}
}

/**
 * Representation of the program's syntax tree.
 */
final class SyntaxTree
{
	private SyntaxTreeNode root = null;

	public SyntaxTreeNode getRoot() { return root; }
	public void setRoot(SyntaxTreeNode root) { this.root = root; }
}

/**
 * Base class for syntax tree nodes.
 */
abstract class SyntaxTreeNode
{
	private List<SyntaxTreeNode> children = new ArrayList<SyntaxTreeNode>();
}

/**
 * Concrete node class representing a unary operator.
 */
class UnaryOperatorNode extends SyntaxTreeNode
{
	public enum Operator
	{
		NOT
	}

	private Operator op;
	private SyntaxTreeNode child;

	public UnaryOperatorNode(Operator op, SyntaxTreeNode child)
	{
		this.op = op;
		this.child = child;
	}

	public Operator getOp() { return op; }
	public void setOp(Operator op) { this.op = op; }

	public SyntaxTreeNode getChild() { return child; }
	public void setChild(SyntaxTreeNode child) { this.child = child; }
}

/**
 * Concrete node class representing a binary operator.
 */
class BinaryOperatorNode extends SyntaxTreeNode
{
	public enum Operator
	{
		EQUAL,
		NOT_EQUAL,
		LESS_THAN,
		LESS_THAN_EQUAL,
		GREATER_THAN,
		GREATER_THAN_EQUAL,
		PLUS,
		MINUS,
		MULTIPLY,
		DIVIDE,
		AND,
		OR
	}

	private Operator op;
	private SyntaxTreeNode left;
	private SyntaxTreeNode right;

	public BinaryOperatorNode(Operator op, SyntaxTreeNode left, SyntaxTreeNode right)
	{
		this.op = op;
		this.left = left;
		this.right = right;
	}

	public Operator getOp() { return op; }
	public void setOp(Operator op) { this.op = op; }
	
	public SyntaxTreeNode getLeft() { return left; }
	public void setLeft(SyntaxTreeNode left) { this.left = left; }

	public SyntaxTreeNode getRight() { return right; }
	public void setRight(SyntaxTreeNode right) { this.right = right; }
}

final class FuncDecl
{
	private String name = null;
	private String[] args = null;

	public String getName() { return name; }
	public void setName(String name) { this.name = name; }

	public String[] getArgs() { return args; }
	public void setArgs(String[] args) { this.args = args; }

	@Override
	public String toString()
	{
		StringBuilder sb = new StringBuilder(name);
		sb.append(", args: ");
		
		for(String arg : args)
		{
			sb.append(arg);
			sb.append(" ");
		}

		return sb.toString();
	}
}

final class PredDecl
{
	@Override
	public String toString()
	{
		return "Predicate";
	}
}

final class PredicateTarget
{
	private boolean all = false;
	private int[] addr = null;

	public void setToAll() { all = true; addr = null; }
	public boolean isToAll() { return all; }

	public void setAddr(int[] addr) { this.addr = addr; all = false; }
	public int[] getAddr() { return addr; }

	public String toString()
	{
		return all ? "all" : addr[0] + "." + addr[1];
	}
}

PARSER_END(Hoppy)

TOKEN : {
	// Keywords
	< USING : 	"using" >
	| < AS :	"as" >
	| < IN : 	"in" >
	| < THIS : 	"this" >
	| < ALL : 	"all" >
	| < COLON :	":" >
	| < TILDE :	"~" >

	// Functions
	| < NEIGHBOURS :	"Neighbours" >
	
	// Operators
	| < LOGICAL_MATH_OP : 	"==" | "!=" | "<" | "<=" | ">" | ">=" >
	| < MATH_OP : 		"+" | "-" | "*" | "/" >
	| < LOGICAL_BIN_OP :	"&" | "|" >
	| < LOGICAL_UN_OP :	"!" >
	| < QUANTIFIER :	"@" | "#" >

	// Regexes
	| < NUMBER :	(<DIGIT>)+ >
	| < NAME :	<LETTER> (<ALPHANUM>)* >
	| < ALPHANUM : 	<LETTER> | <DIGIT> >
	| < #LETTER :	["a"-"z"] >
	| < #DIGIT :	["0"-"9"] >
}

SKIP : { " " | "\t" | "\n" | "\r" }

void Input(PrintStream out) :
{
	PredicateTarget target;
	String using;
}
{
	"[" 
	(
		target = Target()
		{ out.println(target.toString()); }
	)
	"]"
	(
		using = Using()
		{ out.println(using); }
	)
	<EOF>
}

PredicateTarget Target() :
{
	int a, b;
	int[] addr = null;
}
{
	(
		(
			// Flood targeting.
			<ALL>
		)
		|
		(
			// Specific node targeting.
			a = UnsignedCharNumber() "." b = UnsignedCharNumber()
		)
		{
			addr = new int[] { a, b };
		}
	)
	{
		PredicateTarget target = new PredicateTarget();

		if (addr == null) 
		{
			target.setToAll();
		}
		else
		{
			target.setAddr(addr);
		}

		return target;
	}
}

int UnsignedCharNumber() throws ParseException :
{
	Token t;
}
{
	(t = <NUMBER>)
	{
		int i = Integer.parseInt(t.image);

		if (!(i >= 0 && i <= 255))
		{
			throw new ParseException("Integer is not in desired format");
		}

		return i;
	}
}


String Using() :
{
	//Parse a list of aliased functions, return null instead of map if none.
	FuncDecl fn = null;
	Token fnAlias;
	HashMap<String, FuncDecl> usings = null;

	PredDecl pred = null;
}
{
	(
		<USING> 
		(
			fn = Function()
		)
		<AS>
		(
			fnAlias = <NAME>
			{ 
				if(usings == null)
				{
					usings = new HashMap<String, FuncDecl>();
				}
				
				usings.put(fnAlias.image, fn);
			}
		) 
		<IN>
	)* 

	pred = Predicate()

	{
		StringBuilder result = new StringBuilder();
		if(usings == null)
		{
			result.append("No function aliases.\n");
		}
		else
		{
			for(String alias : usings.keySet())
			{
				result.append(usings.get(alias).toString());
				result.append(" aliased as ");
				result.append(alias);
				result.append("\n");
			}
		}

		result.append(pred);

		return result.toString();
	}
} 

FuncDecl Function() :
{
	Token nameToken, argToken;
}
{
	((nameToken = <NEIGHBOURS>) "(" (argToken = <NUMBER>) ")")
	{
		FuncDecl fn = new FuncDecl();
		fn.setName(nameToken.image);
		fn.setArgs(new String[] { argToken.image });
		return fn;
	}
}

PredDecl Predicate() :
{
}
{
	(
		(
			//A quantified predicate over a set.
			<QUANTIFIER> "("
				<NAME> <COLON> <NAME> <TILDE> 
				Predicate() 
			")"
		)
		|
		(
			//A unary operator applied to a predicate.
			<LOGICAL_UN_OP> Predicate()
		)
		|
		(
			//A logical expression.
			LogicalBinaryExpr()
		)
		|
		(
			//An arithmetic expression.
			MathBinaryExpr()
		)
	)
	{ 
		return new PredDecl();
	}
}

void MathBinaryExpr() :
{}
{
	//A logical comparison between two arithmetic expressions.
	<LOGICAL_MATH_OP> VariableExpr() VariableExpr()
}

SyntaxTree VariableExpr() :
{
	SyntaxTree tree = new SyntaxTree();

	//For named values.


	//For literal values.
	Token literal;

	//For arithmetic ops.
	Token op;
	SyntaxTree left;
	SyntaxTree right;
}
{
	(
		//A name (either a variable, or if arguments are supplied, a function).
		<NAME>
		("(" (<NAME> | <THIS>) ")")?
		{
			//named value
		}
	)
	|
	(
		//A literal.
		literal = <NUMBER>
		{
			//Parse the literal and wrap it in a node.
			Integer val = Integer.parseInt(literal.image);
			LiteralNode literalNode = new LiteralNode(val);
			tree.setRoot(literalNode);
			return tree;
		}
	)
	|
	(
		//An arithmetic operation on two variable expressions.
		op = <MATH_OP> 
		left = VariableExpr()
		right = VariableExpr()
		{
			//Combine the two syntax trees with the operator.
			BinaryOperatorNode.Operator opWrapper = BinaryOperatorNode.parseOperator(op.image);
			BinaryOperatorNode bopNode = new BinaryOperatorNode(opWrapper, left, right);
			tree.setRoot(binaryNode);
			return tree;
		}
	)
}

SyntaxTree LogicalBinaryExpr() :
{
}
{
	//A conjunction or disjunction on two predicates.
	<LOGICAL_BIN_OP> Predicate() Predicate()
}


