% !TeX root = Report.tex
\section{Results}

\subsection{Methodology}

In our simulations we tested networks of various sizes (15, 30 and 48 nodes) aligned in a grid. The nodes were placed such that every node had four neighbours, one to the north, south, east and west, except for nodes in the edge which had three neighbours and the nodes in the corner that had two neighbours. The sink was always placed in the top left corner and was always assigned the address ``1.0''. The predicate checking algorithm was started as soon as the nodes had come online, the nodes then waited for 5 minutes to allow the predicate checking algorithm time to setup and then the TDMA algorithm was started. The simulation was run for 35 minutes overall and then it was terminated. After the predicate checking algorithm had setup the predicate was checked every 4 minutes.

To gather metrics on the energy usage of the motes, a Contiki library called rimestats was used. This library is built into the MAC layer and records deep statistics, we simply used the sent and received message counts. In order to calculate how much energy the TDMA algorithm was using we implemented our own sent and received counters that were incremented when a message was sent or received. As the TDMA protocol was implemented with simple broadcasts there should be a one-to-one correspondence between the number of successful broadcasts and the number of transmissions done at the MAC layer, the same is also true for when receiving a message. To calculate the energy cost of the predicate evaluation algorithm, the difference between the total and the TDMA energy usage was taken.

To check that a predicate was successfully evaluated the TDMA algorithm printed any changes in the assigned slot as well as the time the slot was changed. When a predicate was evaluated on a node the time it was evaluated as well as the result was printed. Analysis scripts then evaluated the predicate using the most recent slot value from before or up to when the predicate was evaluated to evaluate the predicate itself. This result was then compared with the actual result of the predicate. The results were compared whether or not the predicate response message reached the sink.

We ran these experiments using two different predicates, one that required 1-hop information and one that required 2-hop information. Both were checking to see if there were slot collisions and were the same two predicate that were mentioned as examples in \autoref{sec:example-predicates}. Below the code and logic for the two predicates is reproduced.

\begin{figure}[H]
\begin{minipage}{.5\linewidth}
\begin{verbatim}
[all]
function 1 as slot returning int in
    using Neighbours(2) as twohopn in
        @(x : twohopn ~
            slot(x) != slot(this)
        )
\end{verbatim}
\end{minipage}%
\begin{minipage}{.5\linewidth}
\begin{align*}
&				\forall n \in \text{Nodes} \cdot \\
& \hspace{2em}		\forall n' \in \text{Neighbours}(n, 2) \cdot \\
& \hspace{4em}				\text{slot}(n) \neq \text{slot}(n')
\end{align*}
\end{minipage}

\caption{Check that no two neighbours have the same slot (2-hop information)}
\label{fig:two-hop-slot-pred-lang-results}
\end{figure}

\begin{figure}[H]
\begin{minipage}{.5\linewidth}
\begin{verbatim}
[all]
function 0 as addr returning int in
function 1 as slot returning int in
    using Neighbours(1) as onehopn in
        @(a : onehopn ~
            @(b : onehopn ~ addr(a) != addr(b)
                => slot(a) != slot(b))
             & slot(a) != slot(this)
        )
\end{verbatim}
\end{minipage}%
\begin{minipage}{.5\linewidth}
\begin{align*}
&				\forall n \in \text{Nodes} \cdot \\
& \hspace{2em}		\forall n' \in \text{Neighbours}(n, 1) \cup \{n\} \cdot \\
& \hspace{4em}			\forall n'' \in \text{Neighbours}(n, 1) \cup \{n\} \cdot \\
& \hspace{6em}				\text{addr}(n') \not= \text{addr}(n'') \\
& \hspace{8em}					\implies \text{slot}(n') \neq \text{slot}(n'')
\end{align*}
\end{minipage}
\caption{Check that no two neighbours have the same slot (1-hop information)}
\label{fig:one-hop-slot-pred-lang-results}
\end{figure}

\subsection{Analysis}

\begin{figure}[H]
\centering
\subfigure[Rx]{%
	\includegraphics[width=0.44\linewidth]{../Results/Graphs/4.0/1HOP/messagesPE/rx/graph.pdf}
	\label{fig:predeval4.0-rx}
}
\subfigure[Tx]{%
	\includegraphics[width=0.44\linewidth]{../Results/Graphs/4.0/1HOP/messagesPE/tx/graph.pdf}
	\label{fig:predeval4.0-tx}
}

\subfigure[Percentage of  predicates correctly evaluated]{%
	\includegraphics[width=0.44\linewidth]{../Results/Graphs/4.0/1HOP/pcCorrectlyEvaluated/graph.pdf}
	\label{fig:predeval4.0-correct}
}
\subfigure[Percentage of responses received]{%
	\includegraphics[width=0.44\linewidth]{../Results/Graphs/4.0/1HOP/pcResponsesReachedSink/graph.pdf}
	\label{fig:predeval4.0-recv}
}
\caption{Results when predicate period is every 4.0 seconds using a 1-hop predicate}
\label{fig:predeval4.0}
\end{figure}

The first point of note from the data presented in \autoref{fig:predeval4.0} is that in \subref{fig:predeval4.0-recv}, is that both of the global predicate evaluation algorithms (PEGE and PEGP) show a 100\% delivery rate. While this may initially appear very impressive, this simply arises from the facts that these predicates are evaluated at the sink, and that the graph shows the receipt of evaluated predicates sent from the evaluation location to the sink -- as no messages need to be sent, it is vacuously true that no messages will fail to arrive. The two local predicate checking algorithms, however, showed a more predictable trend of successfully delivering fewer responses as the network size increased, though the specific values of these rates are disappointingly low. The values suggest that only nodes in the immediate environs of the sink are being successful in sending the results of their predicate evaluations (perhaps a consequence of the mesh routing protocol used for sending this information). As the network grows in size, the proportion of nodes within this range of the sink decreases, resulting in the trend shown.

Graph \subref{fig:predeval4.0-correct}, showing the rate of correct predicate evaluation, reveals much more useful information: locally-evaluated event-triggered predicates show significantly higher accuracy than each of the other algorithms. Global event-based predicates was shown to have the second-highest accuracy, though this accuracy was only slightly higher than that of its periodic counterpart so it cannot be concluded that an event-based approach is universally better (within the scope of this metric). There may be a connection between PELE having the highest number of received messages (graph (a)) and its superior accuracy in evaluation; the premise being that more messages being received could give a node more data to use when evaluating a given predicate, in turn making it more likely to return a correct response. This notion of higher message delivery rates for PELE is somewhat corroborated by the number of transmissions shown in \subref{fig:predeval4.0-tx} -- PELE is responsible for the second lowest number messages sent. However, the cause of PELE alone having a significantly higher success rate in delivering messages is as yet unknown, so more definitive information on this front would require further scrutiny using testing methods that may well prove infeasible in a resource-constrained system.

As messages sent and received use the most energy in a WSN system \cite{?} we will use message transmit and receive statistics to evaluate the energy usage of the algorithms. In graphs \subref{fig:predeval4.0-rx} and  \subref{fig:predeval4.0-tx}), local periodic predicate evaluation is the most conservative, however it also shows the lowest accuracy for its evaluations so these results show little in the way of benefits to using this algorithm. By contrast, the most accurate algorithm, PELE, has a higher (yet still moderate) level of energy consumption. An important observation is that the energy demands of global predicate evaluation -- both of which showed middling accuracy -- increase faster than those of local evaluation as network size increases. This is because global evaluation requires data from the entire network, and the operating of the mesh routing protocol means that nodes lying further from the sink will have to have their messages forwarded by a greater number of intermediate nodes, giving exponential growth in the number of messages sent. The local evaluation algorithms show a more scalar trend as the size of a node's 1- or 2-hop neighbourhood may not increase due to the presence of more nodes in the network -- all that is guaranteed is that there will be more such neighbourhoods in which to evaluate predicates.

\begin{figure}[H]
\centering
\subfigure[Rx]{%
	\includegraphics[width=0.44\linewidth]{../Results/Graphs/2.0/1HOP/messagesPE/rx/graph.pdf}
	\label{fig:predeval2.0-rx}
}
\subfigure[Tx]{%
	\includegraphics[width=0.44\linewidth]{../Results/Graphs/2.0/1HOP/messagesPE/tx/graph.pdf}
	\label{fig:predeval2.0-tx}
}

\subfigure[Percentage of predicates correctly evaluated]{%
	\includegraphics[width=0.44\linewidth]{../Results/Graphs/2.0/1HOP/pcCorrectlyEvaluated/graph.pdf}
	\label{fig:predeval2.0-correct}
}
\subfigure[Percentage of responses received]{%
	\includegraphics[width=0.44\linewidth]{../Results/Graphs/2.0/1HOP/pcResponsesReachedSink/graph.pdf}
	\label{fig:predeval2.0-recv}
}
\caption{Results when predicate period is every 2.0 seconds using a 1-hop predicate}
\label{fig:predeval2.0}
\end{figure}

\begin{figure}[H]
\centering
\subfigure[Rx]{%
	\includegraphics[width=0.44\linewidth]{../Results/Graphs/4.0/2HOP/messagesPE/rx/graph.pdf}
	\label{fig:predeval2hop-rx}
}
\subfigure[Tx]{%
	\includegraphics[width=0.44\linewidth]{../Results/Graphs/4.0/2HOP/messagesPE/tx/graph.pdf}
	\label{fig:predeval2hop-tx}
}

\subfigure[Percentage of predicates correctly evaluated]{%
	\includegraphics[width=0.44\linewidth]{../Results/Graphs/4.0/2HOP/pcCorrectlyEvaluated/graph.pdf}
	\label{fig:predeval2hop-correct}
}
\subfigure[Percentage of responses received]{%
	\includegraphics[width=0.44\linewidth]{../Results/Graphs/4.0/2HOP/pcResponsesReachedSink/graph.pdf}
	\label{fig:predeval2hop-recv}
}
\caption{Results when predicate period is every 4.0 seconds using a 2-hop predicate}
\label{fig:predeval2hop}
\end{figure}

When predicate evaluation algorithms are executed using predicates concerning the 2-hop neighbourhoods of nodes (the results of which are shown in \autoref{fig:predeval2hop}), several measurable differences are immediately apparent when compared to the equivalent 1-hop case of \autoref{fig:predeval4.0}. First and foremost, while the PEGP, PEGE and PELP algorithms in \subref{fig:predeval2hop-tx} show little difference in the numbers of messages transmitted, PELE moves from having the second-fewest transmissions to sending the most messages, even managing to outpace the superlinear growth of the global algorithms -- though PELE itself maintains a linear trend, so one may expect PEGE and PEGP to regain the lead in larger networks than those used for testing. In accordance with this, in \subref{fig:predeval2hop-rx} is seen to PELE extend on its 1-hop lead in number of receptions to receive at least double the number of messages compared to any other algorithm, for any size of network. In short, these results show that local event-based predicate evaluation is significantly less energy-efficient when dealing with a 2-hop neighbourhood.

This loss of efficiency is compounded by the observation in \subref{fig:predeval2hop-correct} that PELE does not even maintain its previous level of accuracy; adding the extra hop to the predicates has caused it to drop by approximately 30 percentage points compared to \autoref{fig:predeval4.0}. Both periodic and event-based global evaluation algorithms have also shown a decrease in accuracy, though by a lesser degree. By contrast, the accuracy of periodic local evaluation has shown an increase. Of these four results, only those for the two global algorithms make intuitive sense -- the added complexity of gathering data from the 2-hop neighbourhood as opposed to only the node's immediate neighbours reduces the probability of all of the requested or required data being received, in turn lowering the probability of correctly evaluating the given predicate. One could perhaps suspect that event-based local evaluation shows such a significant drop because of the significantly increased overlap in the sets of nodes from which each evaluating node is requesting data (leading to more collisions, and similar issues). However, this reasoning does not explain why the accuracy of local periodic evaluation increases; the cohesion between both methods of global evaluation suggests that the difference between periodic and event-based methods does not play a part, and yet the local factor appears unrelated as well.

Less confounding results are found in \subref{fig:predeval2hop-recv}, as the values for the receipt of evaluated predicates are sufficiently similar to those in \autoref{fig:predeval4.0} to conclude that extending predicates to the 2-hop neighbourhood does not appear to impact the success of sending results back to the sink, once the required data has been gathered by the respective nodes. Assuming the explanations made previously were accurate, this is the expected result as only the nodes close to the sink were successfully sending their results for 1-hop predicates, and these nodes will be relatively unaffected by the increased traffic in the majority of the network (and it does not matter if nodes further afield are adversely affected, as the effect cannot worsen their failure).