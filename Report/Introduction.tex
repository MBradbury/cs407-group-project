% !TeX root = Report.tex
\section{Introduction}

\subsection{What is a Wireless Sensor Network?}

A wireless sensor network, or WSN, is a collection of Motes that are capable of short range wireless communication, they also have the ability to sense their surrounding environment\cite{Mica2002,TankBible}. To communicate, each node is equipped with a radio that allows them to send and receive messages to neighbouring nodes within a limited range. To sense the environment motes typically have a range of embedded heat, light, humidity and many other types of sensors. They typically contain a simple central processing unit (CPU) which is typically programmed to control the hardware on the motes, such as the radio and sensors. The CPU also processes events (such as messages being sent and received) created by the hardware and also handles all the other computation necessary for the operation of the Mote. As the platform is designed to be mobile the motes do not operate on a mains power supply, instead they run off stored energy in a battery. 


The fact that they run off a battery is very important as it means there is only a finite supply of energy. As the energy available will eventually run out the platform being deployed (the hardware and the software) must be developed around this limitation to maximise the system's lifetime to maximise the utility that can be got out of the system \cite{1331424}.

While a limited energy source is the predominant characteristic of a wireless sensor node, there are numerous other traits or issues that can be considered. For instance it is possible for these nodes to be mobile (for example an ad-hoc network of PDAs) \cite{4224091} which leads to very interesting behaviour in handling communication between these nodes. Nodes are usually equipped with the same features (such as the same wireless radio), need to withstand harsh outdoor conditions (as that is where they are typically deployed) \cite{SzewczykPMC04, Werner-Allen:2006:FYV:1298455.1298491} and are used in an unattended fashion \cite{1437066}.

As energy usage is limited wireless sensor nodes tend not to use expensive broadcasting protocols such as IEEE 802.11 \cite{Mica2002}, but instead use much simpler alternatives to save energy. For example wireless protocols such as IEEE 802.15.4 ZigBee \cite{1253873, 4014617} are designed to be used by wireless sensor networks and have a lower energy usage associated with them. Some applications rely on even lower level behaviour specified by a certain MAC layer \cite{5751321,4469515,?,BMAC,SMAC,XMAC}, these applications involve a trade-off between development time and energy usage. Where simplicity is often sacrificed for decreased energy usage. Using these simple protocols unfortunately has the downside of meaning that broadcasts are subject to several types of collisions and message losses. So it is very important that the software running on the nodes is designed to handle these cases.

As wireless sensor nodes operate in harsh outdoors condition, there is a high probability of them failing. These faults can range from hardware damage caused by environmental conditions or tampering, software bugs, or simply a denial of service caused by nodes running out of power. So algorithms and software need to be designed to handle these potential failures, otherwise they risk catastrophic failure when they encounter these issues.

\subsection{Debugging Distributed Systems}

Like any system, software or otherwise, developed by humans there is the potential for humans to make mistakes. Mistakes can be benign or they can cause incorrect behaviour and failures. Developing tools to detect these issues and notify the developer so they can be corrected is an incredibly important part of any toolchain. For example the GNU toolchain has utilities such as gdb \cite{?} which allows breakpoint in code to be set and program state to be examined at that point. There are also numerous other tools that look for memory issues (valgrind \cite{?}), security flaws \cite{?} and other classes of bugs. Debugging isolated systems is considered to be a difficult task \cite{?}, debugging distributed systems is considered even harder \cite{345131}.

Developing a distributed system is considered harder because (i) multiple processes execute in parallel, this means that (ii) variables may be updated independently or in repose to other processes and (iii) programming languages are not well suited to develop distributed programs \cite{93692,345131}. As developing distributed systems is hard it also means that testing and debugging are also hard.

When considering a distributed system if you want to examine the state of a system at a given point you cannot simply set a breakpoint in your local binary. The solution to this debugging is non-trivial due to the difficulties that arise because distributed systems are non-deterministic with respect to message communications \cite{?}. Be it when the message started transmission, how long it took, if it succeeded or in what order transmissions occurred. So every time a distributed program is run it is possible for a different result to be obtained, due to the different order of execution. This goes against one of the usual assumptions of debugging traditional applications where it is assume that one execution with a set of inputs will execute in exactly the same way again with the same set of inputs \cite{?} (i.e. determinism).

As the execution may be different each time it is not suitable to wait for a bug to effect the system and then try to work out what the bug is and how to fix it. But the system needs to be paying attention to itself and be able to report if there is an issue. One way to do this it to test if the system satisfies some global predicate, of which there has been much work to find an check different classes of these predicates \cite{553309,345831,277788}. However, of all the work that has been done little of it has focused on wireless sensor networks, where an important focus is perhaps a trade-off of the accuracy or the reportability of a predicate with the aim of reducing energy usage. We intend to focus on developing a system that can accurately evaluate predicates and provide useful information about real sensor networks running outside of a simulator.


\subsection{Related Work - New Lit Review???}

\subsubsection*{Classes of Distributed Predicates}

To begin with it is important to understand what predicates are relevant to distributed systems. First off we have a distinction between global and local predicates, global predicates involve taking a consistent global snapshot of the system and checking whether the snapshot satisfies the global predicate \cite{277788} and local predicates instead work with a subset of the network \cite{553309}. These predicates have also have a notion of stability, a stable predicate will remain true once it has turned true (e.g. termination), whereas unstable predicates can alternate between true and false. Finally there is a distinction between weak and strong, where a weak predicate holds if there exists an observation where the predicate is true and a strong predicate holds if it is true for all observers of the distributed computation\cite{553309,Cooper:1991:CDG:127695.122774}. Knowing what classes of predicates there are is important because when checking certain properties of a system a certain class of predicate will be required and thus a certain implementation will be needed to ensure the predicate is correctly checked. An example of this is when running an algorithm using global snapshots to detect stable predicates, that same application may not be suitable to detect unstable predicates because the predicate could switch to false and then back to true before the next snapshot.

\subsubsection*{Fault-Error-Failure Cycle}

It should be clear that the types of predicates are important to consider when developing a predicate checking mechanism. Also important are the types of errors that these predicate checking algorithms can detect. To understand this it is first important to understand how errors can arise, which can be done by examining the fault-error-failure cycle. This cycle says that a \emph{fault} once caused by either some external influence (e.g. radiation leading to bit-flips in memory \cite{?}) or internal influence (e.g. code bugs) will lead to an \emph{error}, this is the \emph{activation} step. An error is the manifestation of the fault (e.g. memory holding the incorrect value). An error then leads to a \emph{failure} in the step called \emph{propagation}, the failure of the system is an observable deviation from the system's specification (e.g. allowing doors to be opened that should remain closed). It is not always the case the faults lead to errors, or errors lead to failures, sometimes multiple faults or errors are respectively required to cause a single error or failure. \cite{1335465}

There is a choice of what should be measured and checked in predicates, should faults, errors or failures be measured? Faults cannot be measured \cite{?} in a way that is possible for a mote, so they are discounted. That leaves measuring errors and failures. Typically failures would be the event being measured \cite{?} as that is what arises after an error actually causes the issue to happen. However, errors can also be measured if there is a dedicated program checking the state and comparing it to an expected state \cite{?}. For example an ECC (error correcting code) such as a Hamming Code can be used to detect and correct an error (in this case a bit-flip) in some memory after a fault (such as a voltage surge ) \cite{hamming1950error}.

Much of what has been discussed has involved transient faults such as those caused by environmental conditions, however, there is a class of faults that are a lot more common and much easier to resolve - faults caused by software bugs. These faults can lead to programs ending up in the wrong state and performing incorrectly. There has been a certain amount of work that looks into detecting traditional distributed system bugs (such as deadlock \cite{?}) in wireless sensor networks. However, there has been little work in looking into providing tools to aid in system debugging.


\subsubsection*{Existing Sensor Network Predicate Checking Tools}


\subsubsection*{Practical Sensor Network Deployments}



