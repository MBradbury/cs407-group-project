% !TeX root = Report.tex
\section{Practical Experience}

\subsection{Sensor Data Conversion}
Sensors didn't provide data in human understandable formats. Instead they were provided in a raw format that were dependant on several hardware properties of the sensors (such as voltage levels and the number of bits of data a sensor can report). So we  had to convert from raw sensor data to expected results using equations found in \cite{sensiriondatasheet}.

\subsection{Uploading to the motes}
Command used
\begin{listing}
\begin{minted}[fontsize=\small]{bash}
sudo make example-unicast.upload DEFINES=HELLOWORLD,NODE_ID=1 MOTES=/dev/ttyUSB0
\end{minted}
\end{listing}
Adding .upload to the end of the project name, will start the upload to the motes. The MOTES variable is used to locate the USB port for the mote.

The NODE\_ID is used to set the rime address on the nodes. Provided the following macro is inserted into the code. This is important to do because otherwise the MAC address of the node will not be set. Even if the rime address of the node is set, the lack of a MAC address will cause message sent with unicast primitives to fail to arrive, as the address is not correctly set.

\begin{listing} 
\begin{minted}[fontsize=\small]{c}
#ifdef NODE_ID
node_id_burn(NODE_ID);
#endif
\end{minted}
\end{listing}


\subsection{Power Levels}
Using the low power levels (3 or lower) resulted in very unreliable transmission rates/distances. We believe that this was caused by the environment that we were testing in (DCS building), which we expect the traffic on the 2.4GHz frequency to be very busy due to the number of phones and wireless devices in the department.

\subsection{Transmission Ranges}
When developing our mote applications in the simulator there is a very useful feature that allows one to see what the transmission radius of a selected node is. This help developers to work out what the expected behaviour of a piece of software should be. When developing in real-world scenarios, we found that we were never quite sure if our software was simply not working in a real-world environment or if the motes were placed too close to each other or too far.

\subsection{Communication Between Mote and Computer}
To be able to send and receive information between an application running on a mote and an application running on the computer the mote is connected to we needed to use several applications to assist in the data transfer. The easiest flow of data was from the mote to the computer as Contiki supports writing to \verb|stdout| which can then be read using a tool called \verb|serialdump|. Unfortunately Contiki doesn't support writing to \verb|stdout| so we had to develop and alternative method to read data sent from a computer. Also when sending data from the computer application to the mote application we couldn't simply open a filestream in Java and write to that (and expected Contiki to receive it), so we also had to come up with a custom way to do this.

\subsubsection{Receiving Data from Nodes}

\url{http://ai.vub.ac.be/Robotics/wiki/index.php/Compiling,_uploading_and_interacting_with_Contiki:_Hello_World}

\subsubsection{Sending Data to Nodes}

\url{https://github.com/contiki-os/contiki/wiki/Input-and-output#wiki-Serial_Communication}


\subsubsection{Simulating with Cooja}

Use the \verb|serial_socket| plugin to create a serial server or client for a given node. Connect to these via sockets and communicate that way.

\subsection{Developing with Small Message IDs}

When using small message identifiers, after sending enough messages the variable used to hold the identifier will overflow. This make testing if a message has come after another message slightly difficult.

\subsection{Setting up serial2pty Cooja Plugin}

\begin{listing}[H]
\begin{minted}[fontsize=\small]{bash}
cd ~/contiki/tools/cooja/apps
git clone git://i4git.informatik.uni-erlangen.de/contiki_projects.git -b serial2pty serial2pty
cd serial2pty
ant jar
\end{minted}
\end{listing}

Now you can load this plugin in Cooja by going to \verb|Settings| \verb|->| \verb|Cooja Extensions| and selecting serial2pty. Once it has been selected click \verb|Apply for session| and \verb|Save| and the plugin will now be enabled. To run it simply \verb|Tools| \verb|->| \verb| Serial 2 Pty| \verb|->| and select the node you want to connect. You will be told what device you can connect to, to receive the serial output from.

Initially we found that this tool would not build, so a patch was created to fix those issues, sent to the developer and it was integrated into the repository.

\subsection{Cooja Memory Usage  and Options}

We found that Cooja's default settings when run using \verb|ant run| were suitable for smaller networks. However when running more memory intensive applications on the simulator of the hardware in Cooja or when running larger networks, Cooja itself can run out of memory. The simple solution is to simply run Cooja using \verb|ant run_bigmem| which supplies a flag limiting the maximum about of memory to 1536MB instead of 512MB when running normally \cite{?}.

As Cooja is written in Java \cite{?} it means that all of Java's configuration flags are also up for modification. This however, means that the \verb|ant| build script at \verb|~/contiki/tools/cooja/build.xml| will need to be modified to include the flags that need to be passed to Java. We modified the build script to add the following arguments (\verb|-XX:+OptimizeStringConcat| \verb|-XX:UseSSE=3| \verb|-XX:+UseFastAccessorMethods| \verb|-XX:+UseLargePages|) but did not see much improvement of performance.

Finally, there is one other useful mode, and that is the ability to run Cooja without a GUI. This is done by changing the run command to \verb|ant run_nogui|. Running in this mode is very useful when running many simulations to obtain results from them as fast as possible.


\subsection{Static variables}

When developing libraries make sure you use static variables vary carefully. For example we found that commonly we would make callback timers static and then use that object. When the code using that timer will only be called from one place it is okay. However, when you have multiple calls to that timer (imagine broadcasting on different channels) this can cause race conditions as the memory for that timer is being shared. What should be done is the timer object should be placed in a struct and that struct should be passed to the relevant functions that need to access the timer. For each time you wish to use the library a pointer to a different struct should be passed to those functions.

However, there are times that declaring a variable as static is very important. One of these cases is when you have a process that it waiting on some event, if you want a variable to maintain the same value after the event has been waited on, then that variable needs to be static. In \autoref{lst:contiki-process-static-variables} the \verb|printf| statmenet prints out a static and non-static variable. The static counter will increase and be reliably printed out. However, when the variable \verb|x| is printed, the value it contains at that point could be anything. This is due to the way that Contiki's process are actually proto-threads, so share a stack with other proto-threads, if another process were to be scheduled at this point it could potentially modify the stack. This would lead to stack variables such as \verb|x| potentially being changed. On the other hand, if there are no points in the program where the process may yield to other threads, then variables can be non-static. For example \verb|y|'s value would be printed correctly every time.

\begin{listing}[H]
\begin{minted}[fontsize=\small]{c}
PROCESS_THREAD(proc, ev, data)
{
	static struct etimer et;
	static unsigned int counter = 0;

	PROCESS_BEGIN();

	while (true)
	{
		unsigned int x = 1234;

		etimer_set(&et, 10 * CLOCK_SECOND);
		PROCESS_WAIT_EVENT_UNTIL(etimer_expired(&et));

		unsigned int y = 2;

		printf("%u %u %u\n", counter, x, y);

		++counter;
	}

	PROCESS_END();
}
\end{minted}
\caption{Contiki process static variables}
\label{lst:contiki-process-static-variables}
\end{listing}

\subsection{Firmware Size}






