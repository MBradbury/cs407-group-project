options {
  LOOKAHEAD = 1;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  STATIC = true;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = false;
  IGNORE_CASE = false;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
  FORCE_LA_CHECK = false;
}

PARSER_BEGIN(Hoppy)

import java.io.PrintStream;
import java.util.*;

public class Hoppy
{
	public static void main(String args[]) throws ParseException, EvaluationException
	{
		Hoppy parser = new Hoppy(System.in);
		SyntaxTree tree = parser.Input(System.out);

		System.out.println(tree.toString());
	}
}




/**
 * Exception thrown when evaluation of a syntax tree gets into trouble.
 */
class EvaluationException extends Exception
{
	public EvaluationException()
	{
		super("unknown");
	}

	public EvaluationException(String error)
	{
		super(error);
	}

	public String getError()
	{
		return toString();
	}
}

class IncompleteInformationException extends EvaluationException
{
	public IncompleteInformationException()
	{
		super("Can't evaluate this at compile-time.");
	}

	public IncompleteInformationException(String reason)
	{
		super("Can't evaluate this at compile-time: " + reason);
	}
}


abstract class Value
{
}

final class BooleanValue extends Value
{
	private boolean value;
	
	public BooleanValue(boolean value)
	{
		this.value = value;
	}

	public boolean getValue() { return value; }
	public void setValue(boolean value) { this.value = value; }

	@Override
	public String toString()
	{
		return "B:" + value;
	}

	public static BooleanValue assertType(Value val) throws EvaluationException
	{
		if(!(val instanceof BooleanValue))
		{
			throw new EvaluationException("Value type not boolean.");
		}
		else
		{
			return (BooleanValue)val;
		}
	}
}

final class IntegerValue extends Value
{
	private int value;
	
	public IntegerValue(int value)
	{
		this.value = value;
	}

	public int getValue() { return value; }
	public void setValue(int value) { this.value = value; }

	@Override
	public String toString()
	{
		return "I:" + value;
	}

	public static IntegerValue assertType(Value val) throws EvaluationException
	{
		if(!(val instanceof IntegerValue))
		{
			throw new EvaluationException("Value type not integer.");
		}
		else
		{
			return (IntegerValue)val;
		}
	}
}

final class FloatValue extends Value
{
	private float value;
	
	public FloatValue(float value)
	{
		this.value = value;
	}

	public float getValue() { return value; }
	public void setValue(float value) { this.value = value; }

	@Override
	public String toString()
	{
		return "F:" + value;
	}

	public static FloatValue assertType(Value val) throws EvaluationException
	{
		if(!(val instanceof FloatValue))
		{
			throw new EvaluationException("Value type not float.");
		}
		else
		{
			return (FloatValue)val;
		}
	}
}

/**
 * Representation of the program's syntax tree.
 */
final class SyntaxTree
{
	private ISyntaxTreeNode root = null;

	public ISyntaxTreeNode getRoot() { return root; }
	public void setRoot(ISyntaxTreeNode root) { this.root = root; }

	public Value evaluate() throws EvaluationException, IncompleteInformationException
	{
		return root.evaluate();
	}

	@Override
	public String toString()
	{
		return root.toString();
	}
}

/**
 * Base class for syntax tree nodes.
 */
interface ISyntaxTreeNode
{
	Value evaluate() throws EvaluationException, IncompleteInformationException;

	String toString();
}

/**
 * Abstract class representing values.
 */
abstract class ValueNode
{
}

/**
 * Concrete node class representing a named value.
 */
class NamedValueNode extends ValueNode implements ISyntaxTreeNode
{
	private final String name;

	public NamedValueNode(String name)
	{
		this.name = name;
	}

	@Override
	public Value evaluate() throws IncompleteInformationException
	{
		throw new IncompleteInformationException();
	}

	@Override
	public String toString()
	{
		return "Named:" + name;
	}
}

/**
 * Concrete node class representing a literal value.
 */
class LiteralValueNode extends ValueNode implements ISyntaxTreeNode
{
	private Value val;

	public LiteralValueNode(Value val)
	{
		this.val = val;
	}

	public Value getVal() { return val; }
	public void setVal(Value val) { this.val = val; }

	@Override
	public Value evaluate() throws IncompleteInformationException
	{
		return val;
	}

	@Override
	public String toString()
	{
		return val.toString();
	}
}

/**
 * Concrete node class representing a unary operator.
 */
class UnaryOperatorNode implements ISyntaxTreeNode
{
	public enum Operator
	{
		NOT
	}

	private Operator op;
	private ISyntaxTreeNode child;

	public UnaryOperatorNode(Operator op, ISyntaxTreeNode child)
	{
		this.op = op;
		this.child = child;
	}

	public Operator getOp() { return op; }
	public void setOp(Operator op) { this.op = op; }

	public ISyntaxTreeNode getChild() { return child; }
	public void setChild(ISyntaxTreeNode child) { this.child = child; }

	@Override
	public Value evaluate() throws EvaluationException, IncompleteInformationException
	{
		//Evaluate the child node.
		Value childValue = child.evaluate();

		switch(op)
		{
		case NOT:
			//Must be a boolean value for logical inversion.
			BooleanValue val = BooleanValue.assertType(childValue);
		
			//Invert the value;
			val.setValue(!val.getValue());
			return val;

		default:
			throw new EvaluationException("Unrecognised unary operator.");
		}
	}

	@Override
	public String toString()
	{
		return "(" + op.toString() + " " + child.toString() + ")";
	}

	public static Operator parseOperator(String op) throws ParseException
	{
		if(op == "!")	return Operator.NOT;
		else			throw new ParseException("Expected `!'");
	}
}

/**
 * Concrete node class representing an binary operator.
 */
class BinaryOperatorNode implements ISyntaxTreeNode
{
	public enum Operator
	{
		EQUAL,
		NOT_EQUAL,
		LESS_THAN,
		LESS_THAN_EQUAL,
		GREATER_THAN,
		GREATER_THAN_EQUAL,
		
		AND,
		OR,
		XOR,
		IMPLIES,
		EQUIVALENT,

		PLUS,
		MINUS,
		MULTIPLY,
		DIVIDE,
		POWER
	}

	private Operator op;
	private ISyntaxTreeNode left;
	private ISyntaxTreeNode right;

	public BinaryOperatorNode(Operator op, ISyntaxTreeNode left, ISyntaxTreeNode right)
	{
		this.op = op;
		this.left = left;
		this.right = right;
	}

	public Operator getOp() { return op; }
	public void setOp(Operator op) { this.op = op; }
	
	public ISyntaxTreeNode getLeft() { return left; }
	public void setLeft(ISyntaxTreeNode left) { this.left = left; }

	public ISyntaxTreeNode getRight() { return right; }
	public void setRight(ISyntaxTreeNode right) { this.right = right; }

	@Override
	public Value evaluate() throws EvaluationException, IncompleteInformationException
	{
		//Evaluate the child nodes.
		Value leftValue = left.evaluate();
		Value rightValue = right.evaluate();

		switch(op)
		{
		case EQUAL:					return new BooleanValue(BooleanValue.assertType(leftValue).getValue() == BooleanValue.assertType(rightValue).getValue());
		case NOT_EQUAL:				return new BooleanValue(BooleanValue.assertType(leftValue).getValue() != BooleanValue.assertType(rightValue).getValue());
		case LESS_THAN:				return new BooleanValue(IntegerValue.assertType(leftValue).getValue() < IntegerValue.assertType(rightValue).getValue());
		case LESS_THAN_EQUAL:		return new BooleanValue(IntegerValue.assertType(leftValue).getValue() <= IntegerValue.assertType(rightValue).getValue());
		case GREATER_THAN:			return new BooleanValue(IntegerValue.assertType(leftValue).getValue() > IntegerValue.assertType(rightValue).getValue());
		case GREATER_THAN_EQUAL:	return new BooleanValue(IntegerValue.assertType(leftValue).getValue() <= IntegerValue.assertType(rightValue).getValue());


		case PLUS:					return new IntegerValue(IntegerValue.assertType(leftValue).getValue() + IntegerValue.assertType(rightValue).getValue());
		case MINUS:					return new IntegerValue(IntegerValue.assertType(leftValue).getValue() - IntegerValue.assertType(rightValue).getValue());
		case MULTIPLY:				return new IntegerValue(IntegerValue.assertType(leftValue).getValue() * IntegerValue.assertType(rightValue).getValue());
		case DIVIDE:				return new IntegerValue(IntegerValue.assertType(leftValue).getValue() / IntegerValue.assertType(rightValue).getValue());
		case POWER:					return new IntegerValue((int)Math.pow(IntegerValue.assertType(leftValue).getValue(), IntegerValue.assertType(rightValue).getValue()));


		case AND:					return new BooleanValue(BooleanValue.assertType(leftValue).getValue() && BooleanValue.assertType(rightValue).getValue());
		case OR:					return new BooleanValue(BooleanValue.assertType(leftValue).getValue() || BooleanValue.assertType(rightValue).getValue());
		case XOR:					return new BooleanValue(BooleanValue.assertType(leftValue).getValue() ^ BooleanValue.assertType(rightValue).getValue());
		case IMPLIES:				return new BooleanValue(!BooleanValue.assertType(leftValue).getValue() || BooleanValue.assertType(rightValue).getValue());
		case EQUIVALENT:			return new BooleanValue(BooleanValue.assertType(leftValue).getValue() == BooleanValue.assertType(rightValue).getValue());
	
		default:
			throw new EvaluationException("Unrecognised binary operator.");
		}
	}

	@Override
	public String toString()
	{
		return "(" + op.toString() + " " + left.toString() + " " + right.toString() + ")";
	}

	public static Operator parseOperator(String op) throws ParseException
	{
		if(op.equals("=="))			return Operator.EQUAL;
		else if(op.equals("!="))	return Operator.NOT_EQUAL;
		else if(op.equals("<"))		return Operator.LESS_THAN;
		else if(op.equals("<="))	return Operator.LESS_THAN_EQUAL;
		else if(op.equals(">"))		return Operator.GREATER_THAN;
		else if(op.equals(">="))	return Operator.GREATER_THAN_EQUAL;

		else if(op.equals("+"))		return Operator.PLUS;
		else if(op.equals("-"))		return Operator.MINUS;
		else if(op.equals("*"))		return Operator.MULTIPLY;
		else if(op.equals("/"))		return Operator.DIVIDE;
		else if(op.equals("**"))	return Operator.POWER;

		else if(op.equals("&"))		return Operator.AND;
		else if(op.equals("|"))		return Operator.OR;
		else if(op.equals("^"))		return Operator.XOR;
		else if(op.equals("=>"))	return Operator.IMPLIES;
		else if(op.equals("<=>"))	return Operator.EQUIVALENT;

		else						throw new ParseException("Unknown operator: " + op);
	}
}

class QuantifierNode implements ISyntaxTreeNode
{
	public enum Quantifier
	{
		FOR_ALL,
		EXISTS
	}

	private Quantifier quantifier;
	private String var;
	private String set;
	private ISyntaxTreeNode predicate;

	public QuantifierNode(Quantifier quantifier, String var, String set, ISyntaxTreeNode predicate)
	{
		this.quantifier = quantifier;
		this.var = var;
		this.set = set;
		this.predicate = predicate;
	}

	public Quantifier getQuantifier() { return quantifier; }
	public void setQuantifier(Quantifier quantifier) { this.quantifier = quantifier; }
	
	public String getVar() { return var; }
	public void setVar(String var) { this.var = var; }
	
	public String getSet() { return set; }
	public void setSet(String set) { this.set = set; }

	public ISyntaxTreeNode getPredicate() { return predicate; }
	public void setPredicate(ISyntaxTreeNode predicate) { this.predicate = predicate; }

	@Override
	public Value evaluate() throws EvaluationException, IncompleteInformationException
	{
		throw new EvaluationException("TODO");
	}

	@Override
	public String toString()
	{
		return "[" + quantifier.toString() + " " + var+ " " + set + "](" + predicate.toString() + ")";
	}

	public static Quantifier parseQuantifier(String quantifier) throws ParseException
	{
		if(quantifier.equals("@"))		return Quantifier.FOR_ALL;
		else if(quantifier.equals("#"))	return Quantifier.EXISTS;
		else							throw new ParseException("Unknown quantifier: " + quantifier);
	}
}

final class FuncDecl extends ValueNode implements ISyntaxTreeNode
{
	private String name = null;
	private String[] args = null;

	public String getName() { return name; }
	public void setName(String name) { this.name = name; }

	public String[] getArgs() { return args; }
	public void setArgs(String[] args) { this.args = args; }

	@Override
	public Value evaluate() throws IncompleteInformationException
	{
		throw new IncompleteInformationException("Not possible to eval a function");
	}

	@Override
	public String toString()
	{
		StringBuilder sb = new StringBuilder(name);
		sb.append("(");

		if (args.length > 0)
		{
			sb.append(args[0]);

			for (int i = 1; i < args.length; ++i)
			{
				sb.append(", ");
				sb.append(args[i]);
			}
		}

		sb.append(")");

		return sb.toString();
	}
}

final class PredicateTarget
{
	private boolean all = false;
	private int[] addr = null;

	public void setToAll() { all = true; addr = null; }
	public boolean isToAll() { return all; }

	public void setAddr(int[] addr) { this.addr = addr; all = false; }
	public int[] getAddr() { return addr; }

	@Override
	public String toString()
	{
		return all ? "all" : addr[0] + "." + addr[1];
	}
}

PARSER_END(Hoppy)

TOKEN : {
	// Keywords
	  < USING : "using" >
	| < AS :	"as" >
	| < IN : 	"in" >
	| < THIS : 	"this" >
	| < ALL : 	"all" >
	| < COLON :	":" >
	| < TILDE :	"~" >

	// Functions
	| < NEIGHBOURS :	"Neighbours" >

	// Set functions
	| < SET_TRANS_FNS :	"sum" | "mean" | "max" | "min" >
	| < SET_FNS : 		"len" >

	// Variable functions
	| < VAR_FNS :		"abs" >
	
	// Operators
	| < LOGICAL_MATH_OP : 	"==" | "!=" | "<" | "<=" | ">" | ">=" >
	| < MATH_OP : 			"+" | "-" | "**" | "*" | "/" >
	| < LOGICAL_BIN_OP :	"&" | "|" | "^" | "=>" | "<=>" >
	| < LOGICAL_UN_OP :		"!" >
	| < QUANTIFIER :		"@" | "#" >

	// Regexes
	| < NUMBER :	("-")? ["1"-"9"] (<DIGIT>)* >
	| < NAME :		<LETTER> (<ALPHANUM>)* >
	| < ALPHANUM : 	<LETTER> | <DIGIT> >
	| <#LETTER :	["A"-"Z", "a"-"z"] >
	| <#DIGIT :	["0"-"9"] >
}

SKIP : { " " | "\t" | "\n" | "\r" }

SyntaxTree Input(PrintStream out) throws EvaluationException :
{
	PredicateTarget target;
	SyntaxTree tree;
}
{
	"[" 
	(
		target = Target()
		{
			out.println(target.toString());
		}
	)
	"]"
	(
		tree = Using()
		{
			Value val = null;
			boolean evaluated = true;
			try
			{
				val = tree.evaluate();
			}
			catch(IncompleteInformationException ex)
			{
				evaluated = false;
			}

			if(evaluated)
			{
				BooleanValue bv = BooleanValue.assertType(val);
				out.println(bv.getValue());
			}
			else
			{
				out.println("Couldn't evaluate predicate at compile time.");
			}
		}
	)
	<EOF>
	{
		return tree;
	}
}

PredicateTarget Target() throws EvaluationException :
{
	int a, b;
	int[] addr = null;
}
{
	(
		(
			// Flood targeting.
			<ALL>
		)
		|
		(
			// Specific node targeting.
			a = UnsignedCharNumber() "." b = UnsignedCharNumber()
		)
		{
			addr = new int[] { a, b };
		}
	)
	{
		PredicateTarget target = new PredicateTarget();

		if (addr == null) 
		{
			target.setToAll();
		}
		else
		{
			target.setAddr(addr);
		}

		return target;
	}
}

int UnsignedCharNumber() throws ParseException :
{
	Token t;
}
{
	(t = <NUMBER>)
	{
		int i = Integer.parseInt(t.image);

		if (!(i >= 0 && i <= 255))
		{
			throw new ParseException("Integer is not in desired format");
		}

		return i;
	}
}


SyntaxTree Using() throws EvaluationException :
{
	//Parse a list of aliased functions, return null instead of map if none.
	FuncDecl fn = null;
	Token fnAlias;
	HashMap<String, FuncDecl> usings = null;

	ISyntaxTreeNode node;
}
{
	(
		<USING> 
		(
			fn = Neighbours()
		)
		<AS>
		(
			fnAlias = <NAME>
			{ 
				if (usings == null)
				{
					usings = new HashMap<String, FuncDecl>();
				}
				
				usings.put(fnAlias.image, fn);
			}
		) 
		<IN>
	)* 

	node = Predicate()
	{
		//Wrap predicate in syntax tree.
		SyntaxTree tree = new SyntaxTree();
		tree.setRoot(node);	
		return tree;
	}
} 

FuncDecl Neighbours() :
{
	Token nameToken, argToken;
}
{
	((nameToken = <NEIGHBOURS>) "(" (argToken = <NUMBER>) ")")
	{
		FuncDecl fn = new FuncDecl();
		fn.setName(nameToken.image);
		fn.setArgs(new String[] { argToken.image });
		return fn;
	}
}

ISyntaxTreeNode Predicate() throws EvaluationException :
{
	ISyntaxTreeNode node;
	Value val;

	//Quantifier.
	Token quantifier;
	Token var;
	Token set;
	
	//Unary operator.
	Token op;
}
{
	(
		(
			//A quantified predicate over a set.
			quantifier = <QUANTIFIER>
			"("
			var = <NAME>
			<COLON>
			set = <NAME>
			<TILDE>
			node = Predicate()
			")"
			{
				QuantifierNode.Quantifier qWrapper = QuantifierNode.parseQuantifier(quantifier.image);
				QuantifierNode qNode = new QuantifierNode(qWrapper, var.image, set.image, node);

				try
				{
					val = qNode.evaluate();
				}
				catch(IncompleteInformationException ex)
				{
					//Can't evaluate this quantifier at compile time, return.
					return qNode;
				}
				
				return new LiteralValueNode(val);
			}
		)
		|
		(
			//A unary operator applied to a predicate.
			op = <LOGICAL_UN_OP>
			node = Predicate()
			{
				UnaryOperatorNode.Operator opWrapper = UnaryOperatorNode.parseOperator(op.image);
				UnaryOperatorNode uopNode = new UnaryOperatorNode(opWrapper, node);

				try
				{
					val = uopNode.evaluate();
				}
				catch(IncompleteInformationException ex)
				{
					//We can't evaluate this node at compile time, just return it.
					return uopNode;
				}
			
				return new LiteralValueNode(val);
			}
		)
		|
		(
			//A logical expression.
			node = LogicalBinaryExpr()
			{
				return node;
			}
		)
		|
		(
			//An arithmetic expression.
			node = MathBinaryExpr()
			{
				return node;
			}
		)
	)
}

ISyntaxTreeNode MathBinaryExpr() throws EvaluationException :
{
	Token op;
	ISyntaxTreeNode left;
	ISyntaxTreeNode right;
}
{
	//A logical comparison between two arithmetic expressions.
	op = <LOGICAL_MATH_OP>
	left = VariableExpr()
	right = VariableExpr()
	{
		BinaryOperatorNode.Operator opWrapper = BinaryOperatorNode.parseOperator(op.image);
		BinaryOperatorNode bopNode = new BinaryOperatorNode(opWrapper, left, right);

		Value val;
		try
		{
			val = bopNode.evaluate();
		}
		catch(IncompleteInformationException ex)
		{
			//We can't evaluate this at compile time, return the full expression.
			return bopNode;
		}

		return new LiteralValueNode(val);
	}
}

ISyntaxTreeNode VariableExpr() throws EvaluationException :
{
	Value val;

	//For named values.
	Token varname;
	Token varargs = null;

	//For literal values.
	Token literal;

	//For arithmetic ops.
	Token op;
	ISyntaxTreeNode left;
	ISyntaxTreeNode right;
}
{
	(
		//A name (either a variable, or if arguments are supplied, a function).
		varname = <NAME>
		("(" ((varargs = <NAME>) | (varargs = <THIS>)) ")")?
		{
			if (varargs == null)
			{
				return new NamedValueNode(varname.image);
			}
			else
			{
				FuncDecl fn = new FuncDecl();
				fn.setName(varname.image);
				fn.setArgs(new String[] { varargs.image });
				return fn;
			}
		}
	)
	|
	(
		//An arithmetic literal.
		literal = <NUMBER>
		{
			//Parse the literal and wrap it in a node.
			Integer ival = Integer.parseInt(literal.image);
			IntegerValue ivalWrapper = new IntegerValue(ival);
			return new LiteralValueNode(ivalWrapper);
		}
	)
	|
	(
		//An arithmetic operation on two variable expressions.
		op = <MATH_OP> 
		left = VariableExpr()
		right = VariableExpr()
		{
			//Combine the two syntax trees with the operator.
			BinaryOperatorNode.Operator opWrapper = BinaryOperatorNode.parseOperator(op.image);
			BinaryOperatorNode bopNode = new BinaryOperatorNode(opWrapper, left, right);

			try
			{
				val = bopNode.evaluate();
			}
			catch(IncompleteInformationException ex)
			{
				//We can't evaluate this at compile time, return the full node.
				return bopNode;
			}

			return new LiteralValueNode(val);
		}
	)
}

ISyntaxTreeNode LogicalBinaryExpr() throws EvaluationException :
{
	Token op;
	ISyntaxTreeNode left;
	ISyntaxTreeNode right;
}
{
	//A conjunction or disjunction on two predicates.
	op = <LOGICAL_BIN_OP>
	left = Predicate()
	right = Predicate()
	{
		BinaryOperatorNode.Operator opWrapper = BinaryOperatorNode.parseOperator(op.image);
		BinaryOperatorNode bopNode = new BinaryOperatorNode(opWrapper, left, right);

		Value val;
		try
		{
			val = bopNode.evaluate();
		}
		catch(IncompleteInformationException ex)
		{
			//We can't evaluate this at compile time, return the full node.
			return bopNode;
		}

		return new LiteralValueNode(val);
	}
}

